use std::{env, fs, io::Result, path::Path};

use sandy_isa::{
    lexer::{LexError, Token},
    parser::{argchecker::TypeErr, ArgType, ParseError},
    vm::executor::Executor,
};

use ariadne::{ColorGenerator, FileCache, Fmt, Label, Report, ReportKind, Source};

fn main() -> Result<()> {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("error: input file name as the first and only argument");
        std::process::exit(1);
    }

    let program = fs::read_to_string(args[1].clone())?;

    let compiled = sandy_isa::Program::new_from_source(program.clone());

    let program = match compiled {
        Ok(program) => program,
        Err(err) => handle_errs(args[1].clone(), &program, err),
    };

    let mut vm = Executor::new(program);
    vm.run();

    Ok(())
}

fn handle_errs(filename: String, source: &str, err: ParseError) -> ! {
    match err {
        ParseError::SyntaxError(e) => handle_syntax_error(source, e),
        ParseError::TypeError(e) => handle_type_errors(filename, source, e),
    }

    std::process::exit(1);
}

fn handle_type_errors(filename: String, source: &str, errs: Vec<TypeErr>) {
    let mut colors = ColorGenerator::new();
    let col1 = colors.next();
    let col2 = colors.next();
    let col3 = colors.next();

    for err in errs {
        let (begin, end) = err.loc;
        let span = begin..end;

        let mut expected_str = format!(
            "Found {} {} instead of ",
            found_preposition(err.found),
            found_string(err.found).fg(col1)
        );

        if err.expected.len() == 1 {
            expected_str.push_str(&format!(
                "{} {}",
                found_preposition(err.expected[0]),
                found_string(err.expected[0]).fg(col2)
            ));
        } else {
            expected_str.push_str(&format!(
                "{} {} or {} {}",
                found_preposition(err.expected[0]),
                found_string(err.expected[0]).fg(col2),
                found_preposition(err.expected[1]),
                found_string(err.expected[1]).fg(col3)
            ))
        }

        Report::build(ReportKind::Error, (), 0)
            .with_message("Invalid type")
            .with_label(Label::new(span).with_message(expected_str).with_color(col1))
            .finish()
            .print(Source::from(source))
            .unwrap();
    }
}

fn handle_syntax_error(source: &str, err: lalrpop_util::ParseError<usize, Token, LexError>) {
    todo!("Handle the errors generated by LALRPOP");
}

fn found_string(ty: ArgType) -> &'static str {
    match ty {
        ArgType::ImmediateValue => "immediate value",
        ArgType::Register => "register",
        ArgType::Label => "label",
    }
}

fn found_preposition(ty: ArgType) -> &'static str {
    match ty {
        ArgType::ImmediateValue => "an",
        ArgType::Register | ArgType::Label => "a",
    }
}
